(* vim: set filetype=sml: *)
structure A = Absyn

open Symbol

val todoExp = A.NilExp
val todoVar = A.SimpleVar((symbol ""), 0)
val todoExpPos = 0

fun simpleVar(id: string, pos: int) = A.SimpleVar((symbol id), pos)

%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | UMINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | AND | OR 
  | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE

%nonterm  program of A.exp | exp of A.exp
  | decs of A.exp | dec of A.exp
  | tydec of A.exp | vardec of A.exp | fundec of A.exp
  | ty of A.exp | tyfields of A.exp | tyfields_nonempty of A.exp | tyfield of A.exp
  | lvalue of A.var | unitexp of A.exp | arith_exp of A.exp | funcall of A.exp 
  | comp_exp of A.exp | bool_exp of A.exp | record_create of A.exp | array_create of A.exp
  | record_create_list of A.exp | record_create_list_nonempty of A.exp | record_create_field of A.exp
  | expseq of A.exp
  | explist of A.exp | explist_nonempty of A.exp

%nonassoc ASSIGN
%left AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

program: exp                           (exp)

exp
  : lvalue                             (A.VarExp(lvalue))
  | NIL                                (A.NilExp)
  | unitexp                            (unitexp)
  | INT                                (A.IntExp INT)
  | STRING                             (todoExp)
  | MINUS exp             %prec UMINUS (todoExp) (* negate *)
  | funcall                            (todoExp)
  | arith_exp                          (todoExp)
  | comp_exp                           (todoExp)
  | bool_exp                           (todoExp)
  | record_create                      (todoExp)
  | array_create                       (todoExp)
  | lvalue ASSIGN exp                  (todoExp)
  | IF exp THEN exp ELSE exp           (todoExp)
  | IF exp THEN exp                    (todoExp)
  | WHILE exp DO exp                   (todoExp)
  | FOR ID ASSIGN exp TO exp DO exp    (todoExp)
  | BREAK                              (A.BreakExp BREAKleft)
  | LET decs IN expseq END             (todoExp)
  | LPAREN expseq RPAREN               (todoExp)

decs
  :                                    (todoExp)
  | decs dec                           (todoExp)

dec
  : tydec                     (todoExp) 
  | vardec                    (todoExp)
  | fundec                    (todoExp)

tydec: TYPE ID EQ ty          (todoExp)

ty
  : ID                        (todoExp)
  | LBRACE tyfields RBRACE    (todoExp)
  | ARRAY OF ID               (todoExp)

tyfield: ID COLON ID          (todoExp)

tyfields
  :                           (todoExp)
  | tyfields_nonempty         (todoExp)

tyfields_nonempty
  : tyfield                   (todoExp)
  | tyfields COMMA tyfield    (todoExp)

vardec
  : VAR ID ASSIGN exp                  (todoExp)
  | VAR ID COLON ID ASSIGN exp         (todoExp)

fundec
  : FUNCTION ID LPAREN tyfields RPAREN EQ exp       (todoExp)
  | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp  (todoExp)

record_create
  : ID LBRACE record_create_list RBRACE      (todoExp)

record_create_list
  :                                          (todoExp)
  | record_create_list_nonempty              (todoExp)

record_create_list_nonempty
  : record_create_field                                      (todoExp)
  | record_create_list_nonempty COMMA record_create_field    (todoExp)

record_create_field: ID EQ exp         (todoExp)

array_create
  : ID LBRACK exp RBRACK OF exp        (todoExp)

expseq
  : exp                                (todoExp)
  | expseq SEMICOLON exp               (todoExp)

unitexp: LPAREN RPAREN                (A.NilExp)

funcall
  : ID LPAREN explist RPAREN     (todoExp)

explist
  :                              (todoExp)
  | explist_nonempty             (todoExp)

explist_nonempty
  : exp                          (todoExp)
  | explist COMMA exp            (todoExp)
 
arith_exp
  : exp PLUS exp                 (todoExp)
  | exp MINUS exp                (todoExp)
  | exp TIMES exp                (todoExp)
  | exp DIVIDE exp               (todoExp)

comp_exp
  : exp EQ exp                   (todoExp)
  | exp NEQ exp                  (todoExp)
  | exp LT exp                   (todoExp)
  | exp LE exp                   (todoExp)
  | exp GT exp                   (todoExp)
  | exp GE exp                   (todoExp)

bool_exp
  : exp AND exp                  (todoExp)
  | exp OR exp                   (todoExp)

lvalue
  : ID                           (simpleVar(ID, IDleft))
  | ID LBRACK exp RBRACK         (A.SubscriptVar(simpleVar(ID, IDleft), exp, LBRACKleft))
    (* redundant rule to disambiguate with array-creation-expression *)
  | lvalue LBRACK exp RBRACK     (A.SubscriptVar(lvalue, exp, LBRACKleft))
  | lvalue DOT ID                (A.FieldVar(lvalue, (symbol ID), DOTleft))
